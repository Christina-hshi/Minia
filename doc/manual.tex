\documentclass[a4paper]{article}
\usepackage{fancyvrb}
\usepackage{pdfpages}
\begin{document}

\newcommand\vitem[1][]{\SaveVerb[% to use verb in description
    aftersave={\item[\textnormal{\UseVerb[#1]{vsave}}]}]{vsave}}

\title{\Huge \texttt{Minia-GATB} --- Short manual}

\author{R. Chikhi \& G. Rizk \& E. Drezen \& D. Lavenier\\
        {\small{rayan.chikhi@ens-cachan.org}}}
\maketitle

\begin{abstract}
\noindent {\normalsize Minia is a software for ultra-low memory DNA sequence assembly. It takes as input a set of short genomic sequences (typically, data produced by the Illumina DNA sequencer). Its output is a set of contigs (assembled sequences), forming an approximation of the expected genome. Minia is based on a succinct representation of the de Bruijn graph. The computational resources required to run Minia are significantly lower than that of other assemblers.}
\end{abstract}

\tableofcontents

\section{Forewords}

Minia-GATB is the codename of a new version of Minia using the GATB library. We will drop the "-GATB" suffix and just refer to it as "Minia". 
In terms of features, not much has changed: Minia remains a contigs assembler using very low memory. Notable changes are:
\begin{itemize}
    \item Different command line format 
    \item Much faster $k$-mer counting step
    \item Bubbles are collapsed using the most covered path (coverage information is now available for each node in the graph)
\end{itemize}

\section{Installation}

Downlad the binary and run Minia using the comand \verb+./minia+.

To install Minia from the sources, just type: \\ \verb+mkdir build && cd build && cmake .. && make -j 4+ \\
Minia has been tested on Linux and MacOS systems.

\section{Parameters}

The basic usage is:\\

\begin{verbatim}
    ./minia -in [input file] -kmer-size [kmer size] \
            -abundance [abundance value] -out [prefix]
\end{verbatim}


An example command line is:\\


\verb+./minia -in reads.fastq -kmer-size 31 -abundance 3 -out minia_assembly_k31_m3+\\

The parameters are:

\begin{enumerate}

    \item \verb+in+ -- the input file(s) (see Section 5 for inputting multiple files)

    \item \verb+kmer-size+  -- k-mer length (integer)

    \item \verb+abundance+ -- specifies how many times a $k$-mer must be seen in the reads to be considered correct (integer)

\item \verb+prefix+ -- any prefix string to store output contigs as well as temporary files for this assembly

\end{enumerate}

Minia now uses the Cascading Bloom filters improvement (http://arxiv.org/abs/1302.7278) by default, thanks to Gustavo Sacomoto for the implementation in Minia. Launch Minia with the \verb!-debloom original! option to revert to the original data structure.


\section{Explanation of parameters}
\begin{description}

\vitem+kmer-size+
The $k$-mer length is the length of the nodes in the de Bruijn graph. It strongly depends on the input dataset. We recommend that you use the KmerGenie software to automatically find the best $k$ for your dataset.

\vitem+abundance+
The \verb+abundance+ is used to remove erroneous, low-abundance $k$-mers. This parameter also strongly depends on the dataset. Any $k$-mer that appears strictly less than \emph{abundance} times in the reads will be discarded. A typical value is $3$. \textbf{Setting \emph{abundance} to $1$ is not recommended}, as no erroneous $k$-mer will be discarded, which will likely result in a very large memory usage. In particular, if KmerGenie tells you to set abundance to 1, then still, set it to 2. If the dataset has high coverage, try larger values. The KmerGenie software has an experimental feature (in the output of the command, not in the HTML report) 

\vitem+prefix+
The \verb+prefix+ parameter is any arbitrary file name prefix, for example, \verb+test_assembly+.

\end{description}

\section{Input}

\begin{description}
\item \emph{FASTA/FASTQ}

Minia assembles any type of Illumina reads, given in the FASTA or FASTQ format. Giving paired or mate-pairs reads as input is OK, but keep in mind that Minia won't use pairing information.
\item \emph{Multipe Files}

 Minia can assemble multiple input files. Just create a text file containing the list of read files, one file name per line, and pass this list as the first parameter of Minia (instead of a FASTA/FASTQ file). Therefore the parameter \verb+input_file+ can be either (i) the read file itself (FASTA/FASTQ/compressed), or (ii) a file containing a list of file names.
\item \emph{line format}

 In FASTA files, each read can be split into multiple lines, whereas in FASTQ, each read sequence must be in a single line.

\item \emph{gzip compression}

Minia can direclty read files compressed with gzip. Compressed files should end with '.gz'. Input files of different types can be mixed (i.e. gzipped or not, in FASTA or FASTQ)

\end{description}

\section{Output}

The output of Minia is a set of contigs in the FASTA format, in the file \verb+[prefix].contigs.fa+. 

\section{Memory usage}

We estimate that the memory usage of Minia is roughly $1$ GB of RAM per gigabases in the target genome to assemble. It is independent of the coverage of the input dataset, provided that the \verb!abundance! parameter is correctly set. For example, a human genome was assembled in $5.7$ GB of RAM. This was using the original data structure; the current implementation relies on Cascading Bloom filters and uses $\approx 4$ GB. A better estimation of the memory usage can be found in the Minia article.

\section{Disk usage}

Minia writes large temporary files during the k-mer counting phase. These files are written in the working directory when you launched Minia. For better performance, run Minia on a local hard drive. 

\section{Larger $k$-mer lengths}

Minia supports arbitrary large $k$-mer lengths. To compile Minia from the source, to support $k$-mer lengths up to, say, 160, type this in the build folder:
\begin{verbatim}
rm -Rf CMake* && cmake -Dk4=160 .. && make
\end{verbatim}

\end{document}

